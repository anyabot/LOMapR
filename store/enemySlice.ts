import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../store';
import { EnemyData } from '@/interfaces/enemy';


export interface EnemyState {
  enemy: {[key: string]: EnemyData};
  imagelink: {[key: string]: string};
  active: string;
  level: number;
  status: 'idle' | 'loading' | 'failed';
}

const initialState: EnemyState = {
  enemy: {},
  imagelink: {},
  active: "",
  level: 1,
  status: 'idle',
};

export const fetchEnemyAsync = createAsyncThunk<{[key: string]: EnemyData}, void, {state: RootState}>(
  'enemy/fetch',
  async function (_, thunkApi)  {
    if (thunkApi.getState().enemy.status == "failed") return {}
    if (Object.keys(thunkApi.getState().enemy.enemy).length > 0) {
      return thunkApi.getState().enemy.enemy
    }
    else {
      try {
        const response = await fetch("/api/enemy").then(res => res.json())
        return response ? response : {}
      }
      catch {
        return thunkApi.rejectWithValue({})
      }
    }
  }
);

export const fetchEnemyImageAsync = createAsyncThunk<{[key: string]: string}, void, {state: RootState}>(
  'enemy/image',
  async function (_, thunkApi)  {
    if (Object.keys(thunkApi.getState().enemy.imagelink).length > 0) {
      return thunkApi.getState().enemy.imagelink.length
    }
    try {
      const response = await fetch(`/api/enemyImage`).then(res => res.json())
      return response ? response : null
    }
    catch {
      return null
    }
  }
);


export const EnemySlice = createSlice({
  name: 'enemy',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setActive: (state, action: PayloadAction<[string, number]>) => {
      state.active = action.payload[0];
      state.level = action.payload[1];
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchEnemyAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchEnemyAsync.fulfilled, (state, action) => {
        state.enemy = action.payload
      })
      .addCase(fetchEnemyAsync.rejected, (state) => {
        state.status = 'failed';
      })
      .addCase(fetchEnemyImageAsync.fulfilled, (state, action) => {
        if (action.payload) {
          state.imagelink = action.payload
        }
      })
  },
});

export const { setActive } = EnemySlice.actions;
export const selectEnemy = (state: RootState) => state.enemy.enemy;
export const selectEnemyStatus = (state: RootState) => state.enemy.status;
export const selectActiveEnemy = (state: RootState) => state.enemy.active;
export const selectActiveLevel = (state: RootState) => state.enemy.level;
export const selectEnemyImage = (state: RootState) => state.enemy.imagelink;


export default EnemySlice.reducer;